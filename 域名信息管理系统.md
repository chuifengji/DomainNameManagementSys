# 域名信息管理系统

## 一、项目准备

### 1.1 题目要求

**题目描述**：域名的形式为：[www.scuec.edu.cn](http://www.scuec.edu.cn/)，即其数据形式是由4个字符串组成的：www．******．******．******，试设计编写一个域名管理系统程序，使之能提供对域名的录入、查询、修改等基本操作。  

**功能要求即说明**：

- 系统以菜单方式工作  

- 域名信息录入功能（域名信息用文件保存）,从键盘输入数据，保存到磁盘数据文件domain.txt

- 域名信息浏览功能

- 域名信息查询功能

- 域名信息的删除与修改。


### 1.2 我的构想

这个题目给的还是比较泛的，一开始忙着别的事，一直没时间处理这个（好了，其实就是懒）。问过老师详细情况之后，决定开始动手做，总不能一直拖是吧，现在距离截至还有三个星期，我打算花这三天的空余时间把代码整完。到时候再看图形界面是要用未知的MFC还是熟悉一点的web端。好了好了，不说废话，开始正题。

得，你看功能流程图去吧，这玩意也没啥好说的....（懒癌发作）

### 1.3 功能流程图

偷懒，流程图就尽快解决了，我也知道有很多问题。

如下：



![](https://attachments.tower.im/tower/806d28eb84f39c0d74c1b88b78638d6a?download=true)

## 二、类的设计

让我们来理理思路，分为四个类吧，输入类，视图逻辑类，功能类，以及最重要的数据类。

先来谈谈数据类和功能类怎么实现。咳咳。其实很简单，从老师给的条件来看，这完全就是一颗树嘛，而“www”就是根节点。好了，那就简单了。每次输入用户输入的时候做好验证，使用正则保证字符满足域名规则，另外前三个字符也要保证为“www”,字符串要有三个‘.’作为断点。输入完成直接录入到文件当中。浏览就是输出文件数据嘛，当然了也可以做成树的遍历，然后，树的查找，树节点的修改。所谓模糊搜索，害，这不就是二叉搜索树嘛。齐活。不，还没有，我们还得给给对应域名匹配一个随机ip，最好还得保证ip不重复，虽然说重复的几率是很小啦，但咱要求不能这么低呀，还得想个算法不是。

### 2.1 插入以先序遍历demo

````cpp
#include <iostream>
#include <string>
#include <malloc.h>
#include<stdio.h>
#include<stdlib.h>

using namespace std;

typedef struct node
{
 string data;
 node *first_child,*next_sibling;//fc是第一个孩子,nb是fc的临节点
}tree;

tree *root;
void initList()   //方法一
{
	root = new tree;
	root->data = "www";
    root->first_child = NULL;
    root->next_sibling = NULL;
}
tree *createNode(tree *nodeChild,string value){
    nodeChild = new tree;
    nodeChild->data = value;
    nodeChild->first_child = NULL;
    nodeChild->next_sibling = NULL;
    return nodeChild;
}
tree *insertNode(tree *pre,tree *self)
{    //查找待插入的节点在树中是否存在
	tree *B;
	B = pre->first_child;//令B指向要插入节点的父节点的第一个子节点。
	if(B){
        	while(B)
	{
		 if ((B->data)==self->data)
		{
			self = B;  //若存在相等的则返回
		}
		else
		{
			B = B->next_sibling;//否则B指向它的兄弟节点
			if(!B){
                    B = self;
			}
		}
	}
	}else{
	    pre->first_child = self;
	}

	return root;
}
void preOrder(tree *root) {
 cout<<root->data<<endl;
 if (root->first_child != NULL) {
 preOrder(root->first_child);
 }
 if (root->next_sibling != NULL) {
 preOrder(root->next_sibling);
 }
}

int main()
{
    initList();
    tree *scuec = new tree;
    tree *nodeChild = createNode(scuec,"scuec");
    tree *rootl = insertNode(root,nodeChild);
    preOrder(rootl);

}


````

### 2.2 删除指定路径

删除这里要找出规律，我一开始使用的算法非常复杂，容易出错，但是后来我发现，根本没必要。抓住下面几点。对于domain4，不是头节点但有兄弟节点是头节点但无兄弟节点。就删掉。其他节点遵循，没孩子就删掉的原则
                                         

```cpp
tree* Model::deletePath(string domainTwo,string domainThree,string domainFour){
    tree *mediatorOne;
    tree *mediatorTwo;
    tree *mediatorThree;
    tree *mediatorFour;
    tree *virtualRoot;
    virtualRoot = root;
    mediatorOne = root;
    virtualRoot = root->first_child;
    while(virtualRoot){
        if((virtualRoot->data)==domainTwo){
            break;
        }else{
            virtualRoot=virtualRoot->next_sibling;
        }                       //先遍历记录节点。
    }
    mediatorTwo = virtualRoot;//节点二
    //cout<<mediatorTwo->data;
    virtualRoot = virtualRoot->first_child;
        while(virtualRoot){
        if((virtualRoot->data)==domainThree){
            break;
        }else{
            virtualRoot=virtualRoot->next_sibling;
        }
    }
    mediatorThree = virtualRoot;
    //对第四层的操作
    if(mediatorThree->first_child->data==domainFour&&mediatorThree->first_child->next_sibling==NULL){
            mediatorThree->first_child=NULL;
    }else if(mediatorThree->first_child->data==domainFour&&mediatorThree->first_child->next_sibling!=NULL){
        mediatorThree->first_child=mediatorThree->first_child->next_sibling;

    }else{
        mediatorFour=mediatorThree->first_child;
        while(mediatorFour){
            if(mediatorFour->next_sibling->data==domainFour){
                mediatorFour->next_sibling = mediatorFour->next_sibling->next_sibling;
                break;
            }else{
                mediatorFour=mediatorFour->next_sibling;
            }
        }
    }
    //对第三层的操作
    if(!mediatorThree->first_child){
        if(mediatorTwo->first_child->data==domainThree&&mediatorTwo->first_child->next_sibling==NULL){
            mediatorTwo->first_child=NULL;
    }else if(mediatorTwo->first_child->data==domainThree&&mediatorTwo->first_child->next_sibling!=NULL){
        mediatorTwo->first_child=mediatorTwo->first_child->next_sibling;
    }else{
        mediatorThree=mediatorTwo->first_child;
        while(mediatorThree){
            if(mediatorThree->next_sibling->data==domainThree){
                mediatorThree->next_sibling = mediatorThree->next_sibling->next_sibling;
                break;
            }else{
                mediatorThree=mediatorThree->next_sibling;
            }
        }
    }
    }
    //对第二层的操作
        if(!mediatorTwo->first_child){
        if(mediatorOne->first_child->data==domainTwo&&mediatorOne->first_child->next_sibling==NULL){
            mediatorOne->first_child=NULL;
    }else if(mediatorOne->first_child->data==domainTwo&&mediatorOne->first_child->next_sibling!=NULL){
        mediatorOne->first_child=mediatorOne->first_child->next_sibling;
    }else{
        mediatorTwo=mediatorOne->first_child;
        while(mediatorTwo){
            if(mediatorTwo->next_sibling->data==domainTwo){
                mediatorTwo->next_sibling = mediatorTwo->next_sibling->next_sibling;
                break;
            }else{
                mediatorTwo=mediatorTwo->next_sibling;
            }
        }
    }
    }
    //对第一次的操作
    if(root->first_child==NULL){
        root=NULL;
    }

    
    return root;


}

```

​                                                                                              

### 2.3  深度优先搜索以及节点修改demo实现

### 2.4  输入类设计

```cpp
class SelfInput{
private:
    string adminNumber = "undefined";//账号
    string password = "undefined";//密码
    string domainName = "undefined";//域名
public:
    string domainOne = "www";
    string domainTwo = "undefined";
    string domainThree = "undefined";
    string domainFour = "undefined";
    bool verifyIsAdmin(string adminNumber,string password);//验证账号密码
    bool verifyIsDomain(string domainName);//利用正则表达式判断用户输入是否是域名
    void incise(string domainName);
};

    bool SelfInput::verifyIsAdmin(string adminNumber,string password){
        if(adminNumber=="ldl"&&password=="123456"){
            return 1;
        }else{
        return 0;
        }
    };

    bool SelfInput::verifyIsDomain(string domainName){
        regex repPattern("[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.?");// 声明匹配结果变量
        match_results<string::const_iterator> rerResult;// 定义待匹配的字符串
        bool isDomainOne = regex_match(domainName, rerResult, repPattern);
        bool isDomainTwo = domainName.substr(0,3)=="www"?1:0;//首字段是“www”吗
        bool isDomainThree = count(domainName.begin(),domainName.end(),'.')==3?1:0;//是否是四个字段，因为这个程序中我们硬性规定了此域名由四个字段组成。
        if(isDomainOne&&isDomainTwo&&isDomainThree){
            return 1;
        }else{
        return 0;
        }
    };

    void SelfInput::incise(string domainName){
        string domainNameVir;
        domainNameVir = domainName.substr(4);
        int positionTwo = domainNameVir.find(".");
        this->domainTwo = domainNameVir.substr(0,positionTwo);
        domainNameVir = domainNameVir.substr(positionTwo+1);
        int positionThree = domainNameVir.find(".");
        this->domainThree = domainNameVir.substr(0,positionThree);
        this->domainFour = domainNameVir.substr(positionThree+1);
    };
```



### 2.5 文件IO





## 三、完整代码实现

```cpp
#include <iostream>
#include <string>
#include <regex>//引入正则库
#include <malloc.h>
#include<stdio.h>
#include<stdlib.h>
#include <regex>
#include <fstream>
#include <cstdlib>
using namespace std;
//数据功能类
typedef struct node
{
 string data;
 node *first_child,*next_sibling;//fc是第一个孩子,nb是fc的临节点
}tree;

class Model{
private:
    tree *root;
public:
    void initList();//初始化
    void preOrder(tree *root);//先序遍历
    tree* getRoot();//获取根节点
    tree* insertNode(string domainTwo,string domainThree,string domainFour);//插入新节点
    tree* createNode(string value);//生成子节点

};

void Model::preOrder(tree *root){
 cout<<root->data<<endl;
 if (root->first_child != NULL) {
 preOrder(root->first_child);
 }
 if (root->next_sibling != NULL) {
 preOrder(root->next_sibling);
 }
}

void Model::initList(){
    root = new tree;
	root->data = "www";
    root->first_child = NULL;
    root->next_sibling = NULL;
}
tree* Model::getRoot(){
    return root;

}
tree* Model:: createNode(string value){
    tree *nodeChild;
    nodeChild = new tree;
    nodeChild->data = value;
    nodeChild->first_child = NULL;
    nodeChild->next_sibling = NULL;
    return nodeChild;
}


tree* Model::insertNode(string domainTwo,string domainThree,string domainFour)
{
    tree *mediator;
    tree *mediator2;
    tree *mediator3;
    tree *mediator4;
    tree *domainTwoNode = createNode(domainTwo);
    tree *domainThreeNode = createNode(domainThree);
    tree *domainFourNode = createNode(domainFour);
    mediator = root->first_child;

    if(mediator){
            //cout<<mediator->data;
            //第二段
            mediator2 = mediator;
            while(mediator2){
                if((mediator2->data)==domainTwoNode->data){
                    domainTwoNode = mediator2;
                    mediator = mediator2;
                    break;
                }else{
                    mediator = mediator2;
                    mediator2 = mediator2->next_sibling;
                }
            }
            if(!mediator2){
                mediator->next_sibling = domainTwoNode;
            }

            //第三段
            //cout<<mediator->data;
            //cout<<root->first_child->next_sibling->data;
            mediator = domainTwoNode->first_child;

            if(mediator){
                    mediator3 = mediator;
            while(mediator3){
                if((mediator3->data)==domainThreeNode->data){
                        domainThreeNode = mediator3;
                        mediator = mediator3;
                        break;

                }else{
                    mediator = mediator3;
                    mediator3 = mediator3->next_sibling;
                }
            }
            if(!mediator3){
                mediator->next_sibling = domainThreeNode;
            }
            }else{
                domainTwoNode->first_child = domainThreeNode;
            }
            mediator = domainThreeNode->first_child;
            if(mediator){
                    mediator4 = mediator;
            while(mediator4){
                if((mediator4->data)==domainFourNode->data){
                        domainFourNode = mediator4;
                        mediator = mediator4;
                        break;
                }else{
                    mediator = mediator4;
                    mediator4 = mediator4->next_sibling;
                }
            }
            if(!mediator4){
                mediator->next_sibling = domainFourNode;
            }
            }else{
                domainThreeNode->first_child = domainFourNode;
            }

    }else{
        root->first_child = domainTwoNode;
        mediator = domainTwoNode;
        domainTwoNode->first_child = domainThreeNode;
        domainThreeNode->first_child = domainFourNode;
    }
   return root;
}


//输入集合类
class SelfInput{
private:
    string adminNumber = "undefined";//账号
    string password = "undefined";//密码
    string domainName = "undefined";//域名
public:
    string domainOne = "www";
    string domainTwo = "undefined";
    string domainThree = "undefined";
    string domainFour = "undefined";
    bool verifyIsAdmin(string adminNumber,string password);//验证账号密码
    bool verifyIsDomain(string domainName);//利用正则表达式判断用户输入是否是域名
    void incise(string domainName);
};

    bool SelfInput::verifyIsAdmin(string adminNumber,string password){
        if(adminNumber=="ldl"&&password=="123456"){
            return 1;
        }else{
        return 0;
        }
    };

    bool SelfInput::verifyIsDomain(string domainName){
        regex repPattern("[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.?");// 声明匹配结果变量
        match_results<string::const_iterator> rerResult;// 定义待匹配的字符串
        bool isDomainOne = regex_match(domainName, rerResult, repPattern);
        bool isDomainTwo = domainName.substr(0,3)=="www"?1:0;//首字段是“www”吗
        bool isDomainThree = count(domainName.begin(),domainName.end(),'.')==3?1:0;//是否是四个字段，因为这个程序中我们硬性规定了此域名由四个字段组成。
        if(isDomainOne&&isDomainTwo&&isDomainThree){
            return 1;
        }else{
        return 0;
        }
    };

    void SelfInput::incise(string domainName){
        string domainNameVir;
        domainNameVir = domainName.substr(4);
        int positionTwo = domainNameVir.find(".");
        this->domainTwo = domainNameVir.substr(0,positionTwo);
        domainNameVir = domainNameVir.substr(positionTwo+1);
        int positionThree = domainNameVir.find(".");
        this->domainThree = domainNameVir.substr(0,positionThree);
        this->domainFour = domainNameVir.substr(positionThree+1);
    };
int main()
{
    Model model;
    model.initList();
    SelfInput selfInput;


    string domain="www.scuec.cn.nn";
    selfInput.incise(domain);
    model.insertNode(selfInput.domainTwo,selfInput.domainThree,selfInput.domainFour);

    string domainl="www.ldlzds.cn.nn";
    selfInput.incise(domainl);
    model.insertNode(selfInput.domainTwo,selfInput.domainThree,selfInput.domainFour);

    string domainm="www.ldlzds.cm.nn";
    selfInput.incise(domainm);
    model.insertNode(selfInput.domainTwo,selfInput.domainThree,selfInput.domainFour);

    string domainn="www.ldlzds.cn.com";
    selfInput.incise(domainn);
    model.insertNode(selfInput.domainTwo,selfInput.domainThree,selfInput.domainFour);

    string domainp="www.scuec.cn.com";
    selfInput.incise(domainp);
    model.insertNode(selfInput.domainTwo,selfInput.domainThree,selfInput.domainFour);

    tree *root = model.getRoot();
    model.preOrder(model.getRoot());




    //tree *nodeChild = model.createNode(selfInput.domainTwo);
    //model.insertNode(model.getRoot(),nodeChild);

    //tree *nodeChildTwo = model.createNode(selfInput.domainThree);
    //tree *rootEnd = model.insertNode(model.getRoot(),nodeChildTwo);//最后一个节点调用

    //

    //bool test = selfInput.verifyIsAdmin("ldl","123456");
    //bool testOne = selfInput.verifyIsDomain(domain);
    //将输入的域名切割为四个部分。
    return 0;
}


```



## 四、图形界面

### 图你妈，我吐了，不做了！

## 五、结语



附链接：

